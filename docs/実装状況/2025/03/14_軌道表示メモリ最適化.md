# 軌道表示メモリ最適化

## 概要

軌道リスト表示時に400MB近くのメモリを使用していた問題を解決しました。地図表示を伴うアプリケーションでは一定のメモリ使用は避けられませんが、不要なメモリ消費を削減するための最適化を実装しました。

## 問題点

1. `SatelliteOrbitLayer`と`SunOrbitLayer`で軌道ラインをステート変数に保存していたため、Reactのステート管理システムがこれらのオブジェクトをメモリに保持し続けていた

2. 軌道ポイントの数が多く、すべてのポイントを処理・描画していたため、メモリ使用量が増大していた

3. `SatelliteList`コンポーネントでフィルタリング結果をステートに保存していたため、同じデータを二重に保持していた

4. 画面外の軌道も含めてすべての軌道を描画していたため、不要なメモリを消費していた

## 実装した改善策

1. **ステート管理の最適化**：
   - `orbitLines`ステートを削除し、useEffectのローカル変数として管理するように変更
   - `filteredSatellites`ステートを削除し、`useMemo`を使用して計算するように変更

2. **動的な間引き処理**：
   - ズームレベルに応じて軌道ポイントの間引き率を動的に調整
   - 近くを見る（ズームイン）ときは細かく、遠くを見る（ズームアウト）ときは粗く表示

3. **画面外描画の最適化**：
   - 画面外の軌道は描画しない（ただし、画面の端をまたぐ線分は描画）
   - 現在の表示範囲に基づいて必要な部分のみを描画

4. **中間配列の削減**：
   - 軌道計算時の中間配列を削減し、直接変換するように変更
   - 不要なメモリ割り当てを削減

## 技術的な実装

### 1. `SatelliteOrbitLayer.tsx`の最適化

```tsx
// ステートではなくローカル変数として管理
const currentLines: L.Polyline[] = [];

// ズームレベルに応じた間引き率の動的調整
const zoomLevel = map.getZoom();
const skipPoints = zoomLevel > 8 ? 1 : zoomLevel > 5 ? 2 : 3;

// 画面外の軌道は描画しない
const bounds = map.getBounds();
const isPoint1Visible = bounds.contains([point1.lat, point1.lng]);
const isPoint2Visible = bounds.contains([point2.lat, point2.lng]);

if (!isPoint1Visible && !isPoint2Visible) {
  // 画面の端をまたぐ可能性がある場合は描画する
  if (lngDiff < 50) {
    continue;
  }
}
```

### 2. `SunOrbitLayer.tsx`の最適化

```tsx
// ズームレベルに応じて点の間隔を動的に調整
const latStep = zoomLevel > 8 ? 5 : zoomLevel > 5 ? 10 : 15;

// 画面に表示される部分のみを描画するための最適化
let isVisible = false;
for (const point of points) {
  if (bounds.contains(point)) {
    isVisible = true;
    break;
  }
}

// 画面外のポリゴンはスキップ
if (!isVisible && points.length > 10) {
  return null;
}
```

### 3. `SatelliteList.tsx`の最適化

```tsx
// メモリ使用量を削減するためにフィルタリングをステートではなく計算で行う
const filteredSatellites: Array<Satellite & { passes: Pass[] }> = useMemo(() => {
  if (!noradIdFilter) {
    return satellites;
  }
  return satellites.filter(satellite =>
    satellite.id.toString().includes(noradIdFilter)
  );
}, [satellites, noradIdFilter]);
```

## 効果

- メモリ使用量の削減
- 表示品質を維持しながらパフォーマンスを向上
- ズームレベルに応じた適切な詳細度の表示
- 画面外の不要な描画を削減することによるGPUリソースの節約

## 今後の課題

- WebGLを使用した軌道描画の検討（さらなるパフォーマンス向上）
- 軌道計算のワーカースレッド化（メインスレッドの負荷軽減）
- 軌道データの圧縮または効率的なデータ構造の検討
- 大量の衛星を表示する場合のさらなる最適化手法の検討
