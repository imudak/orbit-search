# 軌道表示メモリ最適化

## 概要

軌道リスト表示時に400MB近くのメモリを使用していた問題を解決しました。地図表示を伴うアプリケーションでは一定のメモリ使用は避けられませんが、不要なメモリ消費を削減するための最適化を実装しました。

## 問題点

1. `SatelliteOrbitLayer`と`SunOrbitLayer`で軌道ラインをステート変数に保存していたため、Reactのステート管理システムがこれらのオブジェクトをメモリに保持し続けていた

2. 軌道ポイントの数が多く、すべてのポイントを処理・描画していたため、メモリ使用量が増大していた

3. `SatelliteList`コンポーネントでフィルタリング結果をステートに保存していたため、同じデータを二重に保持していた

4. 画面外の軌道も含めてすべての軌道を描画していたため、不要なメモリを消費していた

## 実装した改善策

1. **ステート管理の最適化**：
   - `orbitLines`ステートを削除し、useEffectのローカル変数として管理するように変更
   - `filteredSatellites`ステートを削除し、`useMemo`を使用して計算するように変更

2. **動的な間引き処理**：
   - ズームレベルに応じて軌道ポイントの間引き率を動的に調整
   - 近くを見る（ズームイン）ときは細かく、遠くを見る（ズームアウト）ときは粗く表示

3. **画面外描画の最適化**：
   - 画面外の軌道は描画しない（ただし、画面の端をまたぐ線分は描画）
   - 現在の表示範囲に基づいて必要な部分のみを描画

4. **中間配列の削減**：
   - 軌道計算時の中間配列を削減し、直接変換するように変更
   - 不要なメモリ割り当てを削減

## 技術的な実装

### 1. `SatelliteOrbitLayer.tsx`の最適化

```tsx
// ステートではなくローカル変数として管理
const currentLines: L.Polyline[] = [];

// ズームレベルに応じた間引き率の動的調整
const zoomLevel = map.getZoom();
const skipPoints = zoomLevel > 8 ? 1 : zoomLevel > 5 ? 2 : 3;

// 画面外の軌道は描画しない
const bounds = map.getBounds();
const isPoint1Visible = bounds.contains([point1.lat, point1.lng]);
const isPoint2Visible = bounds.contains([point2.lat, point2.lng]);

if (!isPoint1Visible && !isPoint2Visible) {
  // 画面の端をまたぐ可能性がある場合は描画する
  if (lngDiff < 50) {
    continue;
  }
}
```

### 2. `SunOrbitLayer.tsx`の最適化

```tsx
// ズームレベルに応じて点の間隔を動的に調整
const latStep = zoomLevel > 8 ? 5 : zoomLevel > 5 ? 10 : 15;

// 画面に表示される部分のみを描画するための最適化
let isVisible = false;
for (const point of points) {
  if (bounds.contains(point)) {
    isVisible = true;
    break;
  }
}

// 画面外のポリゴンはスキップ
if (!isVisible && points.length > 10) {
  return null;
}
```

### 3. `SatelliteList.tsx`の最適化

```tsx
// メモリ使用量を削減するためにフィルタリングをステートではなく計算で行う
const filteredSatellites: Array<Satellite & { passes: Pass[] }> = useMemo(() => {
  if (!noradIdFilter) {
    return satellites;
  }
  return satellites.filter(satellite =>
    satellite.id.toString().includes(noradIdFilter)
  );
}, [satellites, noradIdFilter]);
```

## 効果

- メモリ使用量の削減
- 表示品質を維持しながらパフォーマンスを向上
- ズームレベルに応じた適切な詳細度の表示
- 画面外の不要な描画を削減することによるGPUリソースの節約

## 軌道表示の滑らかさ向上（2025/3/14追加）

メモリ使用量の最適化に加えて、軌道表示の滑らかさを向上させるための改善を実装しました。

### 問題点

- 軌道の表示が荒く、滑らかさに欠けていた
- 特にズームインした際に軌道の角ばった表示が目立っていた
- 日付変更線をまたぐ場合や画面外の軌道の描画条件が厳しく、軌道の連続性が損なわれていた

### 実装した改善策

1. **軌道計算時の間引き率の最小化**：
   - 軌道計算時の間引き率を最小化し、より多くのポイントを使用するように変更
   - `skipPoints`の値を1に設定し、ほぼすべてのポイントを使用

2. **ズームレベルに応じた間引き率の調整**：
   - ズームレベルに応じた間引き率をより細かく調整
   - 高ズームレベル（10以上）では間引きなし（`skipPoints = 0`）
   - 中ズームレベル（8以上）では最小間引き（`skipPoints = 1`）
   - 低ズームレベルでも間引き率を抑制

3. **日付変更線をまたぐ場合の処理の改善**：
   - 日付変更線をまたぐ場合の判定条件を緩和
   - 完全に反対側にある場合（180度以上の差）のみスキップするように変更
   - より連続的な軌道表示を実現

4. **画面外の軌道の描画条件の緩和**：
   - 画面外の軌道の描画条件を緩和（50度→30度）
   - 画面の端をまたぐ線分や近接する可能性のある軌道をより多く描画
   - 軌道の連続性を向上

5. **曲線的な表示の実現**：
   - ポリラインの`smoothFactor`を0.5に設定（デフォルトは1）
   - 直線的ではなく曲線的な表示にすることで視覚的な滑らかさを向上

### 技術的な実装

```tsx
// 軌道計算時の間引き率を最小化
const skipPoints = 1; // 最小の間引き - ほぼすべてのポイントを使用して滑らかに表示

// ズームレベルに応じた間引き率の調整
const zoomLevel = map.getZoom();
const skipPoints = zoomLevel > 10 ? 0 : zoomLevel > 8 ? 1 : zoomLevel > 5 ? 1 : 2;

// 間引き率が0の場合でも正しく動作するように
for (let i = 0; i < segment.points.length - 1; i += Math.max(1, skipPoints)) {
  // ...
}

// 日付変更線をまたぐ場合の処理の改善
let lngDiff = Math.abs(point1.lng - point2.lng);
if (lngDiff > 180) { // 180度以上の差がある場合のみスキップ
  continue;
}

// 画面外の軌道の描画条件の緩和
if (!isPoint1Visible && !isPoint2Visible) {
  if (lngDiff < 30) { // 30度未満の場合のみスキップ
    continue;
  }
}

// 曲線的な表示の実現
const line = L.polyline(segmentPoints, {
  // ...
  smoothFactor: 0.5, // 曲線の滑らかさを設定（値が小さいほど滑らか、デフォルトは1）
  // ...
}).addTo(map);
```

### 効果

- 軌道表示が滑らかになり、視覚的な品質が向上
- 特にズームインした際の軌道の細かい変化がより自然に表現
- 日付変更線をまたぐ場合や画面の端付近での軌道の連続性が向上
- 曲線的な表示により、より自然な軌道の印象を実現

## 今後の課題

- WebGLを使用した軌道描画の検討（さらなるパフォーマンス向上）
- 軌道計算のワーカースレッド化（メインスレッドの負荷軽減）
- 軌道データの圧縮または効率的なデータ構造の検討
- 大量の衛星を表示する場合のさらなる最適化手法の検討
- 軌道の補間アルゴリズムの改善（より滑らかな曲線表現）
