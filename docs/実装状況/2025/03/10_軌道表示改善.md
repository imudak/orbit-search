# 軌道表示改善レポート

## 概要

衛星の軌道表示に関する問題を修正しました。具体的には、仰角（elevation）がマイナスの場合（地平線の下にある場合）でも観測地点近くを軌道が通過してアニメーションされるという不具合を解消しました。

修正内容：
1. 仰角がマイナスの場合の軌道表示ロジックを改善
2. 実効的な角度（effectiveAngle）の計算方法を変更
3. 地平線の下にある衛星の表示方法を最適化

## 変更内容

### 問題の説明

衛星の軌道表示において、以下の問題が発生していました：

- 仰角がマイナスの場合（地平線の下にある場合）でも、観測地点近くを軌道が通過して表示されていた
- 実際には観測地点から見えない（地平線の下にある）衛星が、あたかも近くにあるように表示されていた
- 仰角と地図上の表示位置の関係が直感的でなかった

この問題は、`effectiveAngle`（実効的な角度）の計算方法に起因していました。従来の計算方法では、仰角がマイナスでも観測地点からの距離が近い場合、`effectiveAngle`の値が大きくなり、結果として観測地点近くに表示されていました。

### 修正内容

`orbitWorker.ts`の`effectiveAngle`計算ロジックを変更し、仰角がマイナスの場合は観測地点から遠くに表示されるようにしました：

```typescript
// 修正前
const distanceFactor = Math.max(0, 1 - greatCircleDistance / 90);
const effectiveAngle = elevation * distanceFactor;

// 修正後
const distanceFactor = Math.max(0, 1 - greatCircleDistance / 90);
// 仰角がマイナスの場合（地平線の下にある場合）は、
// 観測地点から遠くに表示されるように非常に小さな値を設定
const effectiveAngle = elevation >= 0
  ? elevation * distanceFactor
  : elevation * 0.01; // 仰角がマイナスの場合は非常に小さな係数を掛ける
```

この修正により：
- 仰角が0以上（地平線上または上）の場合：従来通りの計算方法を使用
- 仰角が0未満（地平線下）の場合：非常に小さな係数（0.01）を掛けることで、観測地点から遠くに表示されるようにした

### 表示への影響

この変更は、`SatelliteOrbitLayer`と`SatelliteAnimationLayer`の表示に影響します：

- `SatelliteOrbitLayer`では、仰角がマイナスの部分の軌道は最も薄い色（グレー）、最も細い線、最も低い透明度で表示される
- `SatelliteAnimationLayer`では、仰角がマイナスの場合、衛星は観測地点から遠くに表示される

## 追加修正（2025/03/10）

### 問題の説明

テストツールで軌道計算の検証を行ったところ、計算自体は正確であることが確認されましたが、地図表示上の軌道が観測地点から大きく東にずれていることが判明しました。

問題点：
- 軌道計算自体は正確に行われている
- 地図表示では、絶対座標（実際の緯度経度）を使用して軌道を表示していた
- 衛星の実際の位置は地球上の別の場所にあるため、絶対座標で表示すると観測地点から離れた場所に表示されていた

### 修正内容

`SatelliteOrbitLayer.tsx`を修正して、絶対座標ではなく相対座標（観測地点からの相対位置）を使用して軌道を表示するようにしました：

```typescript
// 修正前：絶対座標を使用
const segmentPoints = [
  new LatLng(point1.lat, lng1),
  new LatLng(point2.lat, lng2)
];

// 修正後：相対座標を使用
const lng1ForPoint = observerLocation && point1.relLng !== undefined && !isNaN(point1.relLng)
  ? observerLocation.lng + point1.relLng
  : lng1;

const lng2ForPoint = observerLocation && point2.relLng !== undefined && !isNaN(point2.relLng)
  ? observerLocation.lng + point2.relLng
  : lng2;

const segmentPoints = [
  new LatLng(point1.lat, lng1ForPoint),
  new LatLng(point2.lat, lng2ForPoint)
];
```

この修正により：
1. 観測地点が指定されている場合、その経度に相対経度（`relLng`）を加えた値を使用
2. `relLng`が存在しない場合や`NaN`の場合は、正規化された経度を使用
3. `Invalid LatLng object: (30.379812233704232, NaN)`エラーを防止

### 改善効果

1. **軌道表示の正確性向上**
   - 軌道が観測地点を中心として正しく表示されるようになった
   - 相対座標を使用することで、観測地点からの見え方が直感的に理解しやすくなった

2. **エラーの解消**
   - `Invalid LatLng object`エラーが解消され、アプリケーションの安定性が向上

## 今後の課題

1. 軌道表示のさらなる最適化（特に極域や日付変更線付近での表示）
2. 仰角に基づく色分けや表示方法のカスタマイズ機能
3. 地平線の可視化機能の追加
4. 複数衛星の軌道が重なる場合の表示改善
5. 相対座標と絶対座標の切り替え機能の追加
6. 軌道表示の精度向上（特に観測地点から遠い場所での表示）

## まとめ

今回の修正により、衛星の軌道表示がより直感的かつ正確になりました。特に、仰角がマイナスの場合（地平線の下にある場合）の表示が改善され、ユーザーは衛星の可視/不可視状態を視覚的に理解しやすくなりました。また、相対座標を使用することで、軌道が観測地点を中心として正しく表示されるようになりました。これらの改善は、衛星追跡や観測計画の立案において重要な役割を果たすと考えられます。
ただし、スクリーンショットで確認したところ、まだ位置のずれが見られるため、さらなる調整が必要です。

## 追加修正（2025/03/10 18:45）

### 問題の説明

テストツール（map-test.html）で確認したところ、相対座標を使用した表示方法が正確であることが判明しました。本体アプリでも同様の表示方法を適用する必要がありました。また、一部の軌道が途切れて表示される問題も確認されました。

問題点：
- 相対座標の計算方法に一貫性がなかった
- 日付変更線をまたぐ判定の閾値が厳しすぎて、軌道が途切れていた
- TypeScriptの型定義と実際のデータ構造に不一致があった

### 修正内容

1. SatelliteOrbitLayer.tsxの修正：
   ```typescript
   // 相対座標を計算
   let lng1ForPoint = lng1;
   let lng2ForPoint = lng2;

   if (observerLocation) {
     // 観測地点からの相対経度を計算
     let relLng1 = lng1 - observerLocation.lng;
     let relLng2 = lng2 - observerLocation.lng;

     // -180〜180度の範囲に正規化
     while (relLng1 > 180) relLng1 -= 360;
     while (relLng1 < -180) relLng1 += 360;

     while (relLng2 > 180) relLng2 -= 360;
     while (relLng2 < -180) relLng2 += 360;

     // 相対座標を使用
     lng1ForPoint = observerLocation.lng + relLng1;
     lng2ForPoint = observerLocation.lng + relLng2;
   }
   ```

2. 日付変更線をまたぐ判定の閾値を緩和：
   ```typescript
   // 日付変更線をまたぐ場合の処理
   // 経度の差が極端に大きい場合は日付変更線をまたいでいると判断
   let lngDiff = Math.abs(point1.lng - point2.lng);
   if (lngDiff > 170) { // 170度以上の差がある場合は日付変更線をまたいでいる
     // 日付変更線をまたぐ場合は線を引かない
     continue;
   }
   ```

3. orbitWorker.tsの修正：
   ```typescript
   // 相対座標を使用する場合は、不連続点の判定を緩和する
   // 日付変更線をまたぐ場合の閾値を調整（150度→170度）
   if (Math.abs(diff) > 170) {
     isDiscontinuous = true;
     // デバッグログを抑制
     if (process.env.NODE_ENV === 'development' && Math.random() < 0.001) {
       console.log('Discontinuous point detected:', {
         prevLon,
         currentLon: displayLon,
         diff
       });
     }
   }
   ```

### 改善効果

1. **軌道表示の正確性向上**
   - テストツール（map-test.html）と同様の表示方法を適用することで、軌道が観測地点を中心として正しく表示されるようになった
   - 相対座標の計算方法を統一することで、表示の一貫性が向上した

2. **軌道の連続性向上**
   - 日付変更線をまたぐ判定の閾値を緩和することで、軌道が途切れにくくなった
   - 特に地図の端（東側）の軌道が正しく表示されるようになった

3. **TypeScriptエラーの解消**
   - 型定義と実際のデータ構造の不一致を解消し、コードの安定性が向上した
ただし、スクリーンショットで確認したところ、まだ位置のずれが見られるため、さらなる調整が必要です。

## 追加修正（2025/03/10 19:00）

### 問題の説明

地図上で東西の境界（日付変更線付近）で軌道がジャンプする際に、横に線が引かれてしまう問題が発生していました。これは、日付変更線をまたぐ場合の処理が不完全だったことが原因です。

問題点：
- 日付変更線をまたぐ場合（経度が180度から-180度、または-180度から180度に変わる場合）に、地図上で横に線が引かれてしまう
- 初期の経度差チェックでは検出できない場合があった
- 特に相対座標計算後に日付変更線をまたぐケースが考慮されていなかった

### 修正内容

`SatelliteOrbitLayer.tsx`を修正して、相対座標計算後にも日付変更線をまたぐかどうかをチェックするようにしました：

```typescript
// 相対座標計算後に再度日付変更線をまたぐかチェック
let lngDiffAfterRelative = Math.abs(lng1ForPoint - lng2ForPoint);
if (lngDiffAfterRelative > 170) {
  // 相対座標計算後も日付変更線をまたぐ場合は線を引かない
  continue;
}
```

この修正により：
1. 最初に経度差で日付変更線をまたぐかどうかをチェックする処理は維持
2. 相対座標計算後（観測地点からの相対経度を計算した後）に再度日付変更線をまたぐかどうかをチェックする処理を追加

### 改善効果

1. **軌道表示の美観向上**
   - 日付変更線をまたぐ場合に横線が引かれなくなり、地図上の軌道表示が美しくなった
   - 特に世界地図全体を表示した際の見栄えが大幅に改善された

2. **ユーザー体験の向上**
   - 不自然な横線がなくなり、軌道の理解がしやすくなった
   - 地図操作時の視覚的な混乱が減少した

この修正により、軌道表示の品質がさらに向上し、ユーザーにとってより直感的で美しい表示が実現しました。
